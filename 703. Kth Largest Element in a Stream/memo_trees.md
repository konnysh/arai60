- 探索木はkeyを効率的に探すために用いられるデータ構造。操作としてはsearch,insert,delete,min/maxとかが期待される。内部構造としてはあるノードの値keyは、左の部分木の全ノードより大きく、右の部分木の全ノードより小さくなるようにする。mapの実装に使われる。左右に大小関係がある点で、親子関係に大小があるヒープと異なる。参考：[探索木のwikipedia:en](https://en.wikipedia.org/wiki/Search_tree)

- 二分探索木は探索木かつ二分木なもの。操作の実行時間は木の高さに比例するのでアンバランスだと遅くなる。大体の処理の実装は難しくない。子が二つあるノードの削除処理だけ面倒で、削除したノードの位置に、代わりに入るノードが右の部分木の根じゃなければ、ノードの親に子を引き継がせて、部分木の根を代わりのノードの右の子にして、代わりのノードをマージするみたいな作業が要る。実装はarai60のラインナップ的におそらくそのうちやることになるか。

- 二分探索木を効率的に動かすために、木の高さを小さく、どの葉も高さがそう変わらないような木にしたい。この性質を平衡している(balanced)という。平衡していればO(logn)で各種操作が実行できる。平衡にするための方法がいくつかある。

- [AVL木](https://en.wikipedia.org/wiki/AVL_tree)は平衡二分探索木で、高さの差が1までと、平衡性を強めに維持する。追加削除のたびにこの平衡条件を満たしているか確認し、満たしていなければ木の「回転」を行う。3ー2ー1のような直線の形を2を親にして左1,右3に変えるような操作。ただ強めの平衡性を毎回維持するためにオーバーヘッドがかかり、挿入削除が多ければ赤黒木の方が性能が高い。

- [赤黒木](https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)は平衡二分探索木、各ノードに赤か黒の2色の情報を持たせて、色の条件を満たすことで、どの葉からの高さも2倍の範囲に収まる程度の平衡性を持つ。条件は、
    1. 根と葉(葉はNILだが、番兵でノード扱いする)は黒。
    2. 赤の子は黒で赤は連続しない。
    3. 全てのノードについて、「ノードからそれ以下の葉までのパスに含まれる黒の数はどのパスでも同じ」が成り立つ。

  - 追加についてはとりあえず赤で追加して、黒赤赤(G,P,Cとする)になっちゃった並びをC視点からボトムアップの繰り返し処理で以下の戦略で直す。
    - Cから見た叔父(Pの兄弟)が赤なら、Gの黒をPと叔父に配りCは赤にする。赤黒赤、叔父は黒の並びになって、黒の数も配るのでどのパスも黒数は変わらず、この部分木については違反が解消される。
    - 叔父が赤であるために黒配る方法が使えなければ、回転操作をする。下準備としてG→P→Cが左左か右右で辿れていなければ、これを回転でG→Pの方に統一する。回転すると並びはGCPになるが、ここでPの位置をC, Cの位置をPとswapして考える。ここで準備が終わったら回転操作をすれば、P < GCの形になり, Pを黒, GCを赤にすればこの部分木の違反が解消される。
    - 違反を解消した部分木の根をまたCとして繰り返し処理を行う。また回転の向きはG→Pの向きで決まる。(G→P,下準備回転,回転)=(left,left,right),(right, right, left)。左回転は右の子が持ち上がり、右回転は左の子が持ち上がる。
    
  - 削除についてはかなり面倒な場合がある。まず通常の二分探索木のように削除する。削除に伴って、代わりのノードが持ち上げられて削除した色を引き継ぐことになる。
    - 引継ぎ前の元の色について場合分けして確認する。単に削除した点の子が持ち上がる場合については削除した点の色、右の部分木の中から次に大きい値のノードを探して持ち上げる場合についてはそのノードの色を確認する。
    - 赤が消えるもしくは、上に持ち上げられていったとしても赤黒条件は満たしたままになる。黒が消えるもしくは上に持ち上げられていった場合は、パスの黒数が変わったり持ち上げられたノードが元居た場所に詰めるノードが赤の連続となったりで条件を直す必要がある。
     - これを解決するアプローチとしては、元居た場所に詰めるノードの色に黒を仮想的に追加する。このときパスの黒数の条件は問題がなくなるが、そもそもノードの色に黒を追加するとは？となる。削除における赤黒条件の修復というのはつまり、色の塗り替えや回転をすることで、この仮想的な追加黒を黒数の条件を満たしながら動かしていき、色を黒にしてもいい赤ノードに追加黒を押し付ける、つまり黒く塗ることである。
    - 具体的な操作には兄弟の色と兄弟の子の色で場合分けがある。これ以降はちょっと説明が難しい。いつか実装してみる。

