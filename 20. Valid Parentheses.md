# 20. Valid Parentheses
- 問題URL: https://leetcode.com/problems/valid-parentheses/description/
- 言語：C++

## すでに解いた方々 （inレビュー依頼 問題名で検索）
- https://github.com/tarinaihitori/leetcode/pull/7
- https://github.com/BumbuShoji/Leetcode/pull/7
- https://github.com/sendahuang14/leetcode/pull/6
- https://github.com/Yoshiki-Iwasa/Arai60/pull/5
- https://github.com/seal-azarashi/leetcode/pull/6
- https://github.com/kazukiii/leetcode/pull/7
- https://github.com/kagetora0924/leetcode-grind/pull/8
- https://github.com/Ryotaro25/leetcode_first60/pull/7


<br>

## Step1

### 最初に実装したWAになった方法
- `()`,`[]`, `{}`の英語での読み方がわからなかったので、それだけググってからスタート。
- 以下やってたときの思考ログ。
    - カッコ列の問題はstackで上手く管理できる
    - stack自体を作らなくても、stackpointerさえ考えれば管理できそう。
    - intでそれぞれのカッコの深さ管理。
    - submitしたら`({)}`が通らず、種類ごとだけでなく全体としてもちゃんとカッコ列になっていないとダメだと知る。
    - stackを使ってやりなおすことにした。

- 走査していく文字の命名を最初は`current_char`とかにでもしようと思っていた。そこから`current_`には情報ないから要らなくて、`char`だと衝突してしまうなとか考えてたら、`c`の一文字変数になってしまった。今思うと入力はすべてカッコなので、`parenthese`とかでよかったかも。

```C++
/*
 * time:9分37秒
 *
 */
class Solution {
public:
    bool isValid(string s) {
        int count_parentheses = 0;
        int count_square = 0;
        int count_curly = 0;
        for (char c : s) {
            if (c == '(') ++count_parentheses;
            if (c == ')') --count_parentheses;
            if (c == '[') ++count_square;
            if (c == ']') --count_square;
            if (c == '{') ++count_curly;
            if (c == '}') --count_curly;

            if (count_parentheses < 0 || count_square < 0 || count_curly < 0) {
                return false;
            }
        }

        if (count_parentheses != 0 || count_square != 0 || count_curly != 0) {
                return false;
        }
        return true;
    }
};

 ```


 ### stackを使った方法(Accepted)
- stackを使うことにした。
- `pop`が値を返すものかと思っていて一回エラー出した。void型の関数だった。
- ifが多くなりすぎたので、なんか工夫できそう。switchはなんかバグらせそうだったので書かなかった。

```C++
/*
 * time:11分30秒
 *
 */
class Solution {
public:
    bool isValid(string s) {
        std::stack<char> open_parentheses;
        for (char c : s) {
            if (c == '('){
                open_parentheses.push(c);
                continue;
            }
            if (c == '['){
                open_parentheses.push(c);
                continue;
            }
            if (c == '{'){
                open_parentheses.push(c);
                continue;
            }
            if (c == ')'){
                if (open_parentheses.empty()){
                    return false;
                }
                if (open_parentheses.top() != '(') {
                    return false;
                }
                open_parentheses.pop();
                continue;
            }
            if (c == ']'){
                if (open_parentheses.empty()){
                    return false;
                }
                if (open_parentheses.top() != '[') {
                    return false;
                }
                open_parentheses.pop();
                continue;
            }
            if (c == '}'){
                if (open_parentheses.empty()){
                    return false;
                }
                if (open_parentheses.top() != '{') {
                    return false;
                }
                open_parentheses.pop();
                continue;
            }
        }

        if (open_parentheses.empty()) {
                return true;
        }
        return false;
    }
};

 ```

<br>

## Step2

### 調べたことなど
- mapを使う実装は初めて見た。全く選択肢として持っていなかった。同じような対応関係が複数あって、その関係の同じサイドでそれぞれ処理が同じなら、mapを使うと綺麗に出来る。[リファレンス](https://en.cppreference.com/w/cpp/container/map)によるとC++20からcontainsでkeyにあるか確認できる。
- 選択肢として、番兵も使える。今回最後に書いたコードにおいては十分簡潔だと思うので要らなそう。
- 今回のstackの問題で、以下の計算理論に関する用語が連想され、すべて常識だそう。
  - チョムスキー階層・タイプ-2、文脈自由文法、プッシュダウンオートマトン ⇄ 正規言語、正規文法、有限オートマトン

- [チョムスキー階層・タイプ-2](https://en.wikipedia.org/wiki/Chomsky_hierarchy)は初めて知ったが、その他は大学の授業でやった。チョムスキー階層は言語の分類に対して、文法や受理できるオートマトンを整理していて便利な概念だった。オートマトンの授業の時に知りたかった。。。　C言語は文脈依存ではあるはずだからType-2文法？
計算理論の知識については、講義資料のどこ見れば分かるかという参照は覚えているが、おそらく理解が甘く試問されたらボロが出まくると思う。。。
話がズレるがCSの知識というのは、詳細な資料へのポインタと、試問に耐えられる程度の理解のペアの集合なのかもと最近考えた。

- `Parentheses`と`brackets`は[アメリカ英語とイギリス英語の違いらしい](https://en.wikipedia.org/wiki/Bracket)。以下それがまとまった表。

|               | ( )                          | [ ]                          | { }                            | ⟨ ⟩                               |
|---------------|------------------------------|------------------------------|--------------------------------|-----------------------------------|
| アメリカ英語   | parentheses                  | brackets                     | braces                         | angle brackets, chevrons          |
| イギリス英語   | brackets, round brackets     | square brackets              | braces, curly brackets         | angle brackets, chevrons          |


- [条件分岐のスタイルガイド](https://google.github.io/styleguide/cppguide.html#Formatting_Looping_Branching)を確認してみると、if文の後ろに`{}`無しで続ける書き方について、例外的に簡潔になるなら使ってもよいそう。また使うなという場合もあるので、それは周りに合わせる。
- 範囲forを使ったが、スタイルガイド上にはフォーマットについてのみ触れられ、それの使用の是非に関する記述は見つけられなかった。とりあえず使ってしまったけど大丈夫だろうか。。。

- データ構造の選択はオーダーだけじゃなくて内部処理や定数倍、オーバーヘッドを気にする。必要のないスレッドセーフのためのオーバーヘッドがかかったりする。
- [Go言語に関する会話](https://github.com/hroc135/leetcode/pull/6#discussion_r1689055275)。Goの文字列周りの話は共感できた。前にNand2Tetrisの授業で作るコンパイラのバックエンドを、なんとなくGoで作ることにしたが、Goを初めて書くのもあって文字周りで苦しんだ。C++では文字はchar・文字列はstringで大体終わるが、Goだと文字の型も多いし文字列もstringなのかbyteのスライスなのかとか選択があって難しかった。Go自体は新鮮で楽しかった。

<br>

### stackを使った方法
- step1よりかなりスッキリした。
- イギリス英語になるが`bracket`という命名はすべてのカッコを包含できてよい。


```C++
/*
 * Time Complexity :O(N)
 * Space Complexity:O(N)
 *
 */

class Solution {
public:
    bool isValid(string s) {
        std::stack<char> open_brackets;
        std::map<char, char> open_to_close = {
            {'(', ')'},
            {'[', ']'},
            {'{', '}'}};

        for (char bracket : s) {
            if (open_to_close.contains(bracket)) {
                open_brackets.push(bracket);
                continue;
            }
            if (open_brackets.empty() || 
                open_to_close[open_brackets.top()] != bracket) {
                return false;
            }
            open_brackets.pop();
        }
        return open_brackets.empty();
    }
}; 

 ```

<br>

## Step3
- step2と同じコード


```C++
/*
 * time:3分27秒
 * Time Complexity :O(N)
 * Space Complexity:O(N)
 *
 */

 class Solution {
public:
    bool isValid(string s) {
        std::stack<char> open_brackets;
        std::map<char, char> open_to_close = {
            {'(', ')'},
            {'[', ']'},
            {'{', '}'}};
        
        for (char bracket : s) {
            if (open_to_close.contains(bracket)) {
                open_brackets.push(bracket);
                continue;
            }
            if (open_brackets.empty() ||
                open_to_close[open_brackets.top()] != bracket) {
                return false;
            }
            open_brackets.pop();
        }
        return open_brackets.empty();
    }
};

 ```

