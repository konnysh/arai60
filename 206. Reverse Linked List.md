# 206. Reverse Linked List
- 問題URL:https://leetcode.com/problems/reverse-linked-list/description/
- 言語：C++

## すでに解いた方々 （inレビュー依頼 問題名で検索）
- https://github.com/ichika0615/arai60/pull/6
- https://github.com/BumbuShoji/Leetcode/pull/8
- https://github.com/tarinaihitori/leetcode/pull/6
- https://github.com/Mike0121/LeetCode/pull/42
- https://github.com/sendahuang14/leetcode/pull/7
- https://github.com/colorbox/leetcode/pull/22
- https://github.com/ryoooooory/LeetCode/pull/14
- https://github.com/Yoshiki-Iwasa/Arai60/pull/6
- https://github.com/NobukiFukui/Grind75-ProgrammingTraining/pull/33
- https://github.com/seal-azarashi/leetcode/pull/7
- https://github.com/goto-untrapped/Arai60/pull/27
- https://github.com/kazukiii/leetcode/pull/8
- https://github.com/kagetora0924/leetcode-grind/pull/10
- https://github.com/Ryotaro25/leetcode_first60/pull/8 
- https://github.com/TORUS0818/leetcode/pull/9
- https://github.com/fhiyo/leetcode/pull/7

<br>

## Step1

### リストの繋ぎ変えを使った解法
- 以下実装時の思考ログ、実装メモなど
  - 選択としては入力を破壊して繋ぎ変える方法か、newとかで新しく作っていく方向か
  - ループで見て繋ぎ変えていくことにする。
  - nextを後ろに変えていくので、元のnextは持っておく必要がある。
  - 先にheadだけ変える。head次以降をループ
  - prevも持った方がいいかも。
  
- 条件分岐の仕方を悩んだ。 if(next_node)については次ループ抜けるしbreakでもよかったかも。
- previousなのかnextなのか分かりにくいコードになっているかも。
- テーマがstackであることを終わってから思い出したので、そちらの実装もする。


```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
 ```

```C++
/*
 * time:18分7秒
 *
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) {
            return nullptr;
        }
        ListNode *previous_node = nullptr;
        ListNode *node = head;
        ListNode *next_node = head->next;        

        while (node != nullptr) {
            node->next = previous_node;

            previous_node = node;
            node = next_node;
            if (next_node != nullptr) {
                next_node = next_node->next;
            }
        }
        return previous_node;
    }
};

 ```


### stackを使った解法
- 最後のnodeのnextをnullptrに出来ておらず、エラーになった。stackの底にsentinelを置くことで対応した。
- nodeの使いまわしはちょっと行儀が悪いかも　

```C++
/*
 * time:17分32秒
 *
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        std::stack<ListNode*> stack_node;
        stack_node.push(nullptr); //sentinel
        ListNode *node = head;
        while (node != nullptr) {
            stack_node.push(node);
            node = node->next;
        }

        ListNode *tail = stack_node.top();
        stack_node.pop();
        node = tail;
        while (node != nullptr) {
            ListNode *next_node = stack_node.top();
            stack_node.pop();
            node->next = next_node;
            node = next_node;
        }
        return tail;
    }
};

 ```

<br>

## Step2(調べたり・読みやすくしたコード)

### 調べたことなど
- 今回の問題で考える方法としてはこれくらい、再帰1,2は後述する。
  1. スタックで繋ぎ変え。
  2. スタック無しで繋ぎ変え。
  3. 再帰1
  4. 再帰2
  5. newで作る。

- [再帰（ループ）の考え方](https://github.com/NobukiFukui/Grind75-ProgrammingTraining/pull/33#discussion_r1642889760)と[再帰の方法](https://github.com/goto-untrapped/Arai60/pull/27#discussion_r1638693522)2つ。ループの考え方でいうと、自分が前の人から引継ぎされてほしいと思うのは、
 1. 自分が担当する前まではひっくり返しが済んでいる鎖。繋ぎ変えをする輪っかをこっちに向けておいてほしい。
 2. 担当してほしい範囲の最初の輪っか。

  - 次の人には自分が必要だった情報を渡しつつ、成果物のheadは次の人の方が先に分かるのでそれを教えてもらいたい。教えてもらったら、前の人にも教えてあげる。これは再帰の方法でいうと1番目にあたる。1のコードとして示されていたのは読みやすかった。
1が前の人がやったように自分もやるという考え方なのに対して、2は自分の後ろの人が完成させたものに手を加えるみたいな考え方なのかな思った。

- `previous`, `next`の命名に関して、前後というのは作業者が見ているものに対しての相対的な位置でしかなく、真にその変数が持つ性質を反映したものではない。その変数に何を期待するかを命名に入れた方がいい。`previous`だったら「構築してるノードの先頭」で、`next`は「未処理ノードの先頭」みたいな感じ。そうすればstep1で`previous`を返すという違和感を解消できる。

- [else ifに対する考え方の話題](https://github.com/ryoooooory/LeetCode/pull/14#discussion_r1653787365)。ifとelse ifで同じものを対象にしていることが期待される。またelse ifを使うと、ifブロックを抜けた後にも処理があるようなことを期待する。

- [メモリリークに関するお話](https://github.com/Ryotaro25/leetcode_first60/pull/8#discussion_r1615892524)。メモリーリークの話は大学のC++の授業でもかなり重視されていたし、その軽視はレッドカード級というのもうなずける。解決策は所有権の管理やスマートポインタがある。
  - 関連する話題にShallow copy（浅いコピー）によるアクセス違反・二重解放なんかもある。ポインタを含むオブジェクトのコピーで解放済みのメモリにアクセスしたり、動的メモリ割り当てを含むオブジェクトの関数への受け渡しにおいてデストラクタが2回呼ばれて同じメモリが二度解放されてしまうこと。習った当時はしっくりこなかったが、今はスタックのイメージがついてきたので、原理からちょっと理解できている気がする。関数渡しでの違反は次の関数のスタックフレームの上に引数としてコピーするためで、関数から返す違反はスタックフレームがどいた後に返す値のコピーを残すためだと思う。

- Pythonでよく見るが、ある関数の実装を補助する関数で引数を増やしたような関数は、AuxiliaryやHelperを関数名の後ろにつけて呼ばないことを示す。

<br>

### stackを使って繋ぎ変える方法
- step1の改良のようなコード
- nextのnextを自分に向けると逆順にできる。
- stack_nodesの命名, nodeの使いまわしは改良の余地ありかも。
- step1にあったtailの命名は今回も良くなさそうだったのでなくした。元のリストのtailではあるが、今回は返すリストのheadなのでただtailにしても誤解を招く。



```C++
/*
 * Time Complexity :O(N)
 * Space Complexity:O(N)
 *
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) {
            return nullptr;
        }
        ListNode *node = head;
        std::stack<ListNode*> stack_nodes;
        while (node != nullptr) {
            stack_nodes.push(node);
            node = node->next;
        }

        ListNode *reversed_head = stack_nodes.top();
        stack_nodes.pop();
        while (!stack_nodes.empty()) {
            node = stack_nodes.top();
            stack_nodes.pop();
            node->next->next = node;
            node->next = nullptr;
        }
        return reversed_head;
    }
};


 ```


### stack無しで繋ぎ変える方法
- step1の改良のようなコード
- 命名によってprevious返す違和感問題を解決した。


```C++
/*
 * Time Complexity :O(N)
 * Space Complexity:O(1)
 *
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) {
            return nullptr;
        }
        ListNode *reversed = nullptr;
        ListNode *node = head;
        while (node != nullptr) {
            ListNode *unprocessed = node->next;
            node->next = reversed;
            reversed = node;
            node = unprocessed;
        }
        return reversed;
    }
};

 ```

### 再帰1
- 再帰の方法1のコードのほぼC++翻訳版、自分の再帰のイメージに合っているのはこっち。
- 個人的な趣味で命名を変えた(rest→node)。再帰を人間の鎖の作業で例えたとき、作業者は残りの鎖よりも自分の領分の鎖にフォーカスしているイメージがあるためそれに沿った名前にした。好みにしてしまったが分かりやすさを変えてしまっていないだろうか。。。

```C++
/*
 * Time Complexity :O(N)
 * Space Complexity:O(1)
 *
 */

class Solution {
public:
    ListNode *reverseList(ListNode *head) {
        return reverseListHelper(nullptr, head);
    }

private:
    ListNode *reverseListHelper(ListNode *reversed, ListNode *node) {
        if (node == nullptr) {
            return reversed;
        }
        ListNode *rest_tail = node->next;
        node->next = reversed;
        return reverseListHelper(node, rest_tail);
    }
};


 ```

### 再帰2
- 再帰の方法2のコード
- nodeがreversed_headになるパターンをまとめた。
- reversed_headとprocessed_tailでひっくり返し済みの範囲を命名した。tailの前におく単語をheadと統一していないのは、reversed_tailをいじくるのは嫌な感じがして、processed_tailなら今はtailも計算途中で、新しくnodeを計算済みの範囲に追加するというのを分かって貰えそうと思ったため。

```C++
/*
 * Time Complexity :O(N)
 * Space Complexity:O(1)
 *
 */
class Solution {
public:
    ListNode *reverseList(ListNode *head) {
        return reverseListHelper(head);
    }

private:
    ListNode *reverseListHelper(ListNode *node) {
        if (node == nullptr || node->next == nullptr) {
            return node;
        }

        ListNode *processed_tail = node->next;
        ListNode *reversed_head = reverseListHelper(processed_tail);
        processed_tail->next = node;
        node->next = nullptr;
        return reversed_head;
    }
};

 ```

<br>

## Step3

### stackを使って繋ぎ変える方法
- step2と同一のコード

```C++
/*
 * time :2分42秒
 * Time Complexity :O(N)
 * Space Complexity:O(N)
 *
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) {
            return nullptr;
        }
        std::stack<ListNode*> stack_nodes;
        ListNode *node = head;
        while (node != nullptr) {
            stack_nodes.push(node);
            node = node->next;
        }

        ListNode *reversed_head = stack_nodes.top();
        stack_nodes.pop();
        while (!stack_nodes.empty()) {
            node = stack_nodes.top();
            stack_nodes.pop();
            node->next->next = node;
            node->next = nullptr;
        }
        return reversed_head;
    }
};

 ```


### stack無しで繋ぎ変える方法
- step2と同一のコード

```C++
/*
 * time:1分28秒
 * Time Complexity :O(N)
 * Space Complexity:O(1)
 *
 */

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if (head == nullptr) {
            return nullptr;
        }
        ListNode *reversed = nullptr;
        ListNode *node = head;
        while (node != nullptr) {
            ListNode *unprocessed = node->next;
            node->next = reversed;
            reversed = node;
            node = unprocessed;
        }
        return reversed;
    }
};

 ```

### 再帰1
- step2のコードと同一

```C++
/*
 * time :1分30秒 
 * Time Complexity :O(N)
 * Space Complexity:O(1)
 *
 */

class Solution {
public:
    ListNode *reverseList(ListNode *head) {
        return reverseListHelper(nullptr, head);
    }

private:
    ListNode *reverseListHelper(ListNode *reversed, ListNode *node) {
        if (node == nullptr) {
            return reversed;
        }
        ListNode *rest_tail = node->next;
        node->next = reversed;
        return reverseListHelper(node, rest_tail);
    }
};

 ```

### 再帰2
- step2のコードと同一

```C++
/*
 * time :1分53秒
 * Time Complexity :O(N)
 * Space Complexity:O(1)
 *
 */
class Solution {
public:
    ListNode *reverseList(ListNode *head) {
        return reverseListHelper(head);
    }

private:
    ListNode *reverseListHelper(ListNode *node) {
        if (node == nullptr || node->next == nullptr) {
            return node;
        }

        ListNode *processed_tail = node->next;
        ListNode *reversed_head = reverseListHelper(processed_tail);
        processed_tail->next = node;
        node->next = nullptr;
        return reversed_head;
    }
};

 ```

<br>
